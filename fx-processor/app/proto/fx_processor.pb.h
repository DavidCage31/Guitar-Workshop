// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/fx_processor.proto

#ifndef PROTOBUF_proto_2ffx_5fprocessor_2eproto__INCLUDED
#define PROTOBUF_proto_2ffx_5fprocessor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace fxp {
class AudioRequest;
class AudioRequestDefaultTypeInternal;
extern AudioRequestDefaultTypeInternal _AudioRequest_default_instance_;
class AudioRequest_ParamsEntry;
class AudioRequest_ParamsEntryDefaultTypeInternal;
extern AudioRequest_ParamsEntryDefaultTypeInternal _AudioRequest_ParamsEntry_default_instance_;
class AudioResponse;
class AudioResponseDefaultTypeInternal;
extern AudioResponseDefaultTypeInternal _AudioResponse_default_instance_;
}  // namespace fxp

namespace fxp {

namespace protobuf_proto_2ffx_5fprocessor_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_proto_2ffx_5fprocessor_2eproto

enum AudioEffect {
  DISTORTION = 0,
  REVERB = 1,
  DELAY = 2,
  AudioEffect_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AudioEffect_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AudioEffect_IsValid(int value);
const AudioEffect AudioEffect_MIN = DISTORTION;
const AudioEffect AudioEffect_MAX = DELAY;
const int AudioEffect_ARRAYSIZE = AudioEffect_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioEffect_descriptor();
inline const ::std::string& AudioEffect_Name(AudioEffect value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioEffect_descriptor(), value);
}
inline bool AudioEffect_Parse(
    const ::std::string& name, AudioEffect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioEffect>(
    AudioEffect_descriptor(), name, value);
}
// ===================================================================


// -------------------------------------------------------------------

class AudioRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fxp.AudioRequest) */ {
 public:
  AudioRequest();
  virtual ~AudioRequest();

  AudioRequest(const AudioRequest& from);

  inline AudioRequest& operator=(const AudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AudioRequest(AudioRequest&& from) noexcept
    : AudioRequest() {
    *this = ::std::move(from);
  }

  inline AudioRequest& operator=(AudioRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioRequest& default_instance();

  static inline const AudioRequest* internal_default_instance() {
    return reinterpret_cast<const AudioRequest*>(
               &_AudioRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AudioRequest* other);
  friend void swap(AudioRequest& a, AudioRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AudioRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AudioRequest& from);
  void MergeFrom(const AudioRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AudioRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, float> params = 3;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, float >&
      params() const;
  ::google::protobuf::Map< ::std::string, float >*
      mutable_params();

  // bytes audio = 1;
  void clear_audio();
  static const int kAudioFieldNumber = 1;
  const ::std::string& audio() const;
  void set_audio(const ::std::string& value);
  #if LANG_CXX11
  void set_audio(::std::string&& value);
  #endif
  void set_audio(const char* value);
  void set_audio(const void* value, size_t size);
  ::std::string* mutable_audio();
  ::std::string* release_audio();
  void set_allocated_audio(::std::string* audio);

  // .fxp.AudioEffect effect = 2;
  void clear_effect();
  static const int kEffectFieldNumber = 2;
  ::fxp::AudioEffect effect() const;
  void set_effect(::fxp::AudioEffect value);

  // @@protoc_insertion_point(class_scope:fxp.AudioRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class AudioRequest_ParamsEntry : public ::google::protobuf::internal::MapEntry<AudioRequest_ParamsEntry, 
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<AudioRequest_ParamsEntry, 
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > SuperType;
    AudioRequest_ParamsEntry();
    AudioRequest_ParamsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const AudioRequest_ParamsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_AudioRequest_ParamsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      AudioRequest_ParamsEntry,
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > params_;
  private:
  ::google::protobuf::internal::ArenaStringPtr audio_;
  int effect_;
  mutable int _cached_size_;
  friend struct protobuf_proto_2ffx_5fprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fxp.AudioResponse) */ {
 public:
  AudioResponse();
  virtual ~AudioResponse();

  AudioResponse(const AudioResponse& from);

  inline AudioResponse& operator=(const AudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AudioResponse(AudioResponse&& from) noexcept
    : AudioResponse() {
    *this = ::std::move(from);
  }

  inline AudioResponse& operator=(AudioResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioResponse& default_instance();

  static inline const AudioResponse* internal_default_instance() {
    return reinterpret_cast<const AudioResponse*>(
               &_AudioResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AudioResponse* other);
  friend void swap(AudioResponse& a, AudioResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AudioResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AudioResponse& from);
  void MergeFrom(const AudioResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AudioResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes processed_audio = 1;
  void clear_processed_audio();
  static const int kProcessedAudioFieldNumber = 1;
  const ::std::string& processed_audio() const;
  void set_processed_audio(const ::std::string& value);
  #if LANG_CXX11
  void set_processed_audio(::std::string&& value);
  #endif
  void set_processed_audio(const char* value);
  void set_processed_audio(const void* value, size_t size);
  ::std::string* mutable_processed_audio();
  ::std::string* release_processed_audio();
  void set_allocated_processed_audio(::std::string* processed_audio);

  // @@protoc_insertion_point(class_scope:fxp.AudioResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr processed_audio_;
  mutable int _cached_size_;
  friend struct protobuf_proto_2ffx_5fprocessor_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AudioRequest

// bytes audio = 1;
inline void AudioRequest::clear_audio() {
  audio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AudioRequest::audio() const {
  // @@protoc_insertion_point(field_get:fxp.AudioRequest.audio)
  return audio_.GetNoArena();
}
inline void AudioRequest::set_audio(const ::std::string& value) {
  
  audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fxp.AudioRequest.audio)
}
#if LANG_CXX11
inline void AudioRequest::set_audio(::std::string&& value) {
  
  audio_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fxp.AudioRequest.audio)
}
#endif
inline void AudioRequest::set_audio(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fxp.AudioRequest.audio)
}
inline void AudioRequest::set_audio(const void* value, size_t size) {
  
  audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fxp.AudioRequest.audio)
}
inline ::std::string* AudioRequest::mutable_audio() {
  
  // @@protoc_insertion_point(field_mutable:fxp.AudioRequest.audio)
  return audio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioRequest::release_audio() {
  // @@protoc_insertion_point(field_release:fxp.AudioRequest.audio)
  
  return audio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioRequest::set_allocated_audio(::std::string* audio) {
  if (audio != NULL) {
    
  } else {
    
  }
  audio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audio);
  // @@protoc_insertion_point(field_set_allocated:fxp.AudioRequest.audio)
}

// .fxp.AudioEffect effect = 2;
inline void AudioRequest::clear_effect() {
  effect_ = 0;
}
inline ::fxp::AudioEffect AudioRequest::effect() const {
  // @@protoc_insertion_point(field_get:fxp.AudioRequest.effect)
  return static_cast< ::fxp::AudioEffect >(effect_);
}
inline void AudioRequest::set_effect(::fxp::AudioEffect value) {
  
  effect_ = value;
  // @@protoc_insertion_point(field_set:fxp.AudioRequest.effect)
}

// map<string, float> params = 3;
inline int AudioRequest::params_size() const {
  return params_.size();
}
inline void AudioRequest::clear_params() {
  params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, float >&
AudioRequest::params() const {
  // @@protoc_insertion_point(field_map:fxp.AudioRequest.params)
  return params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, float >*
AudioRequest::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:fxp.AudioRequest.params)
  return params_.MutableMap();
}

// -------------------------------------------------------------------

// AudioResponse

// bytes processed_audio = 1;
inline void AudioResponse::clear_processed_audio() {
  processed_audio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AudioResponse::processed_audio() const {
  // @@protoc_insertion_point(field_get:fxp.AudioResponse.processed_audio)
  return processed_audio_.GetNoArena();
}
inline void AudioResponse::set_processed_audio(const ::std::string& value) {
  
  processed_audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fxp.AudioResponse.processed_audio)
}
#if LANG_CXX11
inline void AudioResponse::set_processed_audio(::std::string&& value) {
  
  processed_audio_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fxp.AudioResponse.processed_audio)
}
#endif
inline void AudioResponse::set_processed_audio(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  processed_audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fxp.AudioResponse.processed_audio)
}
inline void AudioResponse::set_processed_audio(const void* value, size_t size) {
  
  processed_audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fxp.AudioResponse.processed_audio)
}
inline ::std::string* AudioResponse::mutable_processed_audio() {
  
  // @@protoc_insertion_point(field_mutable:fxp.AudioResponse.processed_audio)
  return processed_audio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioResponse::release_processed_audio() {
  // @@protoc_insertion_point(field_release:fxp.AudioResponse.processed_audio)
  
  return processed_audio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioResponse::set_allocated_processed_audio(::std::string* processed_audio) {
  if (processed_audio != NULL) {
    
  } else {
    
  }
  processed_audio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processed_audio);
  // @@protoc_insertion_point(field_set_allocated:fxp.AudioResponse.processed_audio)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace fxp

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fxp::AudioEffect> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fxp::AudioEffect>() {
  return ::fxp::AudioEffect_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2ffx_5fprocessor_2eproto__INCLUDED
